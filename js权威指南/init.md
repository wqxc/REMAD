读了几遍都是半途而废了，这次是无论如何也要读完！
而且，打算一边读，一边记录一下读后感！
坚持读完吧1

词法：
1.js区分大小写，但是，HTML却不区分大小写，这点容易混淆。
2.js忽略空格换行等标识。
3.数字不能作为变量的首字符，可以使用字母，下划线$符。
4.js的数字类型分为两类：原始数据类型和对象数据类型。
数字、字符串、布尔值是原始数据类型
除了数字、字符串、布尔值、undefined 之外都是对象

5.如果一个函数用来初始化一个新的对象，那么这个函数就被称之为构造函数
6.从技术上讲只有对象才能拥有方法，然而，一些字符串，数字，布尔值也可以拥有方法。
只有null和undefined无法拥有方法。

7.js的变量是无类型的变量，而且，js采用词法作用于。
声明在函数外的变量，全局都可以引用，声明在函数内的变量只能再函数内部使用。

8.js中字符串都是不变的，每次的操作之后返回的是一个新的字符串。
原字符串不会发生任何改变。

9.假值 undefined、null、0、NaN、''、false
，除以上六个外，都是真值。


10.字符串使用属性：
var s = '123'
var a = s.split('')
字符串不是对象，为什么会有属性可以来使用：
是因为，一旦，你使用字符串调用属性的时候，这个字符串就会在js内部通过 new String()的方式，
将这个字符串转化为对象，而在调用结束之后，新建的对象就会销毁。
同样的。number boolean 也可以使用属性。
看起来就像是根据提供的值，建造了一个临时的对象，通过这个对象来访问属性，访问结束之后，这个临时的
对象就会被销毁。
这些所有的属性都是只读的，你不能尝试给这些属性赋值。因为，即使你给这些属性赋值，也只是保存在一个临时的对象里的，
一旦属性引用完毕，这个对象就会被销毁，你赋的值就一同被销毁掉。
这些临时创造的变量叫做包装对象。

我们可以通过new方法创建显示的包装对象，不会被销毁的包装对象。
var S = new String(s)
S就是一个字符对象。
number，boolean也是这样。


11。原始值：
number、boolean、string、null、undefined.
这五个是原始值或者是原始数据类型，或者是基本数据类型。
这些值是不可变的，一旦创建就不会改变。
比如，string你看到的是可以对他进行加长或者是切开，但是，这些操作之后返回的是一个新的值，原本的值是不会发生改变的。
与这些原始值相反的是，对象的值是可以改变的。这些对象我们又称之为引用类型或者引用数据类型。




12.类型转换：

null 转换为字符串：'null'，转换为数字：0
undefined 转为字符串 'undefined' 转换为数字： NaN
''转换为字符串 空  转换为数字 0

在运算中
{}+2//2
{}表示0
而{}+'abc'//NaN
因为abc无法转换为数字。
但是，但是：Number({})//NaN
不得不说这很奇葩
{}在加减操作的时候被认为是一个数字。
但是
1+{}//"1[object Object]"
然而，上边的理论是错误的，正确的如下：
{}在操作的时候被认为是一个数字是不对的，实际上在进行操作的时候，{}被认为是一个代码块，code block
  而且是一个空的代码块，
  类似于
  {


  }
  +1
  那么
  {

  }
  会直接被忽略掉的。
  不信的话可以试试将两者括起来
  ({}+1)//'[object Object]1'


然后：
[]+1//'1'
[]+'abc'//'abc'
String([])//''
[]这个玩意儿在运算中被认为是一个空字符串，而且它确实是可以被String()
转换为空字符串。
但是，但是Number([])//0
1+[]//'1'
这是什么鬼。运算的时候难道不是把[]，Number()一下吗？
实际上，+号最先进行的是一个连接操作，而不是加法运算。



而如果数组不是空的。比如：[9,1,2]会直接将中括号换成双引号。
Number([9])//9
1+[9]//'19'
[9]+1//'91'

Number([9,12])//NaN
[9,12]+1//'9,121'

这真是奇怪的很。
然而。问题的关键是：

如果+是一元操作符的话，其作用类似于Number()
如果+是二元的操作符的。操作的一半是string,那么不管另外一个是什么类型的，都会将两者按照字符串拼接。
我查了一下资料，发现，在运算的时候好像，+这个操作，优先推断两个是string的,，而如果这个时候，恰好其中一个是string那么，就是链接操作。
但是，-、*、/ 这三个操作则默认为是数字间操作。

比如：
1-[]//1
1/[]//infinity
1*[]//0    





13.number类型的数字转换
toString()//可以将一根数字转为为指定进制的字符串，其中toString()接受的参数就是进制数，不写参数，则表示是十进制。
toExponential()//将一个数字转换为指数计数法--字符串。
比如：
var count = 1000000000
count.toExponential()
"1e+9"
toFixed()//可以接受一个参数。这个参数表示保留小数后几位？最后转换为一个字符串。


toPrecision() //接受一个参数。表示，你要转换的结果是有多少位，如果多的话会四舍五入，少的话会以0补充。
比如：
var count = 1000000000
count.toPrecision(5)
"1.0000e+9"
我们要求有五位，1后就填充四个0.
再比如：
var count = 1000000000.123123123123123123123
count.toExponential(2)
"1.000000000123e+9"


parseInt()
parseFloat()
两个会忽略需要转换的对象的前导空格，而后，忽略数字后的内容，而如果第一个非空的字符不是数值，
那么直接返回一个NaN。
parseInt()可以接受第二个参数作为进制转换的基准值：基准值值的是，你要转换的数是进制的。而这个参数的取值范围是2-32
比如：
parseInt('99988',2)//NaN 因为二进制中最大的数是1
parseInt('11',2)//3 正确。





14.所有的对象都继承了两个转换方法。
toString()//会返回一个反映这个对象的字符串。
({1:2}).toString()//"[object Object]"
Number(1).toString()//"1"

有一些类定义了不同的toString()的实现方法。
比如数组。数组的toString()方法，是将数组内的元素用逗号拼接起来。
比如函数。函数的toString()方法，会返回这个函数的表达式。
Date类。返回一个可读的时间字符串。
new Date().toString()// "Tue Dec 25 2018 13:32:34 GMT+0800 (中国标准时间)"
RegExp。将会直接以字符串的形式返还。


valueOf()//大多时候，默认返回对象本身。
Date类。的valueof()方法返回一个1970年以来的毫秒数。


将一个对象转换为字符串会经过下列几个步骤
  1.如果有toString()方法就调用toString()方法，如果，toString()返回一个原始值，
  那么将原始值转换为字符串输出。
  2.如果对象没有toString()方法，或者是这个方法，无法返回一个原始值，
  那么就调用valueOf()方法，如果存在valueOf()方法，且返回一个原始值，就将这个原始值转换为字符串输出。
  3.否则的话，就抛出错误异常。

  var obj = {
    "x":1,
    "y":2,
    "toString":function(){
      return {x:1,y:2}
    }
  }
  如上，我们修改了obj的toString方法，此时操作obj+"123".则会报错。
  因为，按照上述的逻辑进行连接操作，
  1.调用toString方法，得出的结果是一个对象{x:1，y:2}这个返回值不是原始值，
  所以继续调用valueOf()方法，得到的结果是obj对象自身，也不是一个原始值，
  无法转换为字符串，所以就报错了。



而，如果将一个对象转换为一个数字
  1.首先判断是否有valueof()方法，有的话就调用，然后返回一个原始值，而后再将原始值转换为数字。
  2.如果没有valueof()方法，那么就调用toString()方法，而后输出一个字符串，再将字符串转换为数字
  3.否则的话，就报错，类型错误。

原始值：number、boolean、string、null、undefined.


  以上可以解释
  为什么？+[]//0
  Number([])//0
  String([])//''

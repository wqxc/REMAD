0.指令的bind与update

1。滥用箭头函数。vue里箭头函数与真正的this指向的位置是不同的。
正常我们希望this代指整个vue组件，但是，箭头函数下，this指向的是函数本身。

2.set,触发视图更新，vue2里监控的是整个对象，触发一个属性更新，造成监控这个对象的全部
属性都执行。

3.刷新组件。使用v-if的时候没有刷新。这个和js的执行顺序有关，
同步的代码是结合到一起进行执行的，先后修改v-f的值，只有最后的一次是被操作了的。

4.node的版本问题，6.9版本
10.13版本，不同的版本造成项目打包与部署的问题。

5.分层，单一职责原则、最少知识原则

assets目录。放置静态资源。
Api文件，将所有的api接口进行集成
components 组件目录，一些公共组件或者是模块组件。
store文件夹，状态管理器
util工具文件夹，将一些工具函数，集成之后使用
包含一些指令或者是过滤器这些东西。
Router路由文件夹，将路由


6.单个vue文件越来越大。视图层做了太多的业务操作，文件显得更加臃肿，不便于维护，
迭代更新都会很麻烦。
如果多个页面用到了同样的代码，如果单纯的重复只会造成后期的修改很麻烦。
方向是将这些业务逻辑进行抽离与集成。


7.Remd.md文件，表示项目的一些基本信息，方便与快速的启动项目。


8.vue3.0
会兼容vue2.x，模板语法之类的，不会改动，一些高层的API会发生变动，
一些的细节实现会发生一些改变。
默认为惰性监测（Lazy Observation）。在 2.x 版本中，任何响应式数据，不管它的大小如何，都会在启动的时候被监测。
如果你的数据量很大的话，在应用启动的时候，这就可能造成可观的性能消耗。
而在 3.x 版本中，只有应用的初始可见部分所用到的数据会被监测，更不用说这种监测方案本身其实也是更加快的。

更精准的变动通知。举个例子：在 2.x 系列中，通过 Vue.set 强制添加一个新的属性，将导致所有依赖于这个对象的 watch 函数都会被执行一次；
而在 3.x 中，只有依赖于这个具体属性的 watch 函数会被通知到。

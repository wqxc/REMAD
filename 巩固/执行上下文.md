在js代码被执行，执行上下文会被压进执行栈中，但是在此之前还有一步工作要做，就是创建好执行上下文。
1.执行上下文的组成部分：
  AO对象/VO对象，作用域链，this值。


一。VO对象就是变量对象，包含当前执行代码的全部的变量声明或者是函数声明的一个集合。
  js中之所以有声明的提升是因为变量对象(VO)对象的存在。
  比如以下是我们要执行的一段代码：
  console.log(a);
  console.log(b);
  console.log(c);
  console.log(d);
  var a = 100;
  b = 10;
  function c(){};
  var d = function(){};

  首先打印出来的是a值为undefined。
  因为在执行之前首先会创建执行上下文，或者称之为执行的环境。
  类似于：VO={
    a:undefined,
    c:function c(){},
    d:undefined
  }
  这些是在代码执行之前就需要率先确认的执行环境。
  因为b并没有使用var进行声明，所以，我们认为他是不存在于此上下文的。
  规则是率先提取出声明的变量和函数，函数因为声明的规则不同，所以提取的内容也是不同。
  这也是为什么，函数声明的函数能够在声明之前就被执行，而函数表达式不行。
  如上，我们执行上下文的一个方面，VO对象呗率先制造出来。

  而后代码被压入执行栈的时候会顺着执行，打印a，打印b，打印c，打印d，而后给a赋值，给d赋值。(c已经存在了)。

二。 如果我们执行的一个函数此时就不是VO对象了，而是AO对象(活动对象)包含当前这个函数的执行的环境。
活动对象是在函数执行上下文里面的，其实也是变量对象，只是它需要在函数被调用时才被激活，而且初始化arguments，激活后就是看做变量对象执行上面一样的步骤。
  比如下边的这个函数：
  function f(name){
    var age=2;
    console.log(name)
  }
  f('john')
  在初始化的时候有一个AO对象：
  AO={
    arguments:[name],//希望有两个变量
    name:undefined,
    age:undefined,
  }
  而后被压入执行栈中执行的时候AO对象被激活。
  当上面的函数fn被调用，就会创建一个执行上下文，同时活动对象被激活，类似于下边这样：
  var AO = {
    arguments:[0:john],
    name:john,
    age:undefined
  }
  而后在函数执行到age=2的时候，AO对象的age被赋值。


三。作用域链：在创建执行上下文时还要创建一个重要的东西，就是作用域链。每个执行环境的作用域链由当前环境的变量对象及父级环境的作用域链构成
  以下边的函数来举例：
  function fn(a,b){
      var x = 'string',
  }
  fn(1,2)

  函数在被调用前会先进行初始化。
  fn有个私有属性[[scope]],它会被初始化为当前全局的作用域，fn.[[scope]="globalScope"。

  调用函数fn(1,2)，开始创建fn执行上下文，同时创建作用域链fn.scopeChain = [fn.[[scope]]]，此时作用域链中有全局作用域。
  此时还会有一个AO对象AO={
    arguments:[a,b],//希望有两个变量
    a:undefined,
    b:undefined,
    x:undefined
  }
  此时是函数没有被调用之前做的操作。

  而后函数被调用。
  fn活动对象AO被初始化后，把活动对象作为变量对象推到作用域链前端，此时fn.scopeChain = [fn.AO,fn.[[scope]]]，构建完成，此时作用域链中有两个值，一个当前活动对象，一个全局作用域。
  因为这个作用域链的存在，js才能访问到外部的变量。

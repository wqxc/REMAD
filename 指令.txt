在我看来，指令的作用就是为了能够直接的来修改DOM。
一些vue内置的指令，
比如v-if v-else v-show v-bind v-html v-text 等等的指令，
或多或少都是用来直接的操作DOM，
如果你不知道什么时候使用指令？那么请记住一点。
那就是，在你需要操作DOM的时候，请选择使用指令来进行。
vue提供的，每一种工具最好就是只针对某一种行为来使用是最好的。
现在，我们就来说说指令。
一些内置的指令也就不需要说了，直接上手自定义的指令。
首先，指令分为局部的指令和全局的指令，
先来说一下局部的指令。
如下vue的官方文档的一个例子是。
new Vue({
  el: '#app',
  data: {
    message: 'hello!'
  },
  directives: {
    focus: {
      // 指令的定义
      inserted: function (el) {
        el.focus()
      }
    }
  }
})
使用的方式是
<div id="app">
  <input type="text" name="" value="" v-focus >
</div>

我们定义了一个叫做focus的指令，它的作用就是在inserted的时候，让一个input获得焦点。
其中directives 是一个对象，它可以接收多个参数（参数都是方法，或者称之为钩子函数更为贴切）。
以下是官方文档的说法：
bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
  意思是，这个钩子函数只被调用一次，如果你想在某些变量发生变化的情况下，重新的执行指令，那么该钩子函数不行。



update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。
指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。
  VNode 是虚拟的DOM，vue会在虚拟的DOM的基础上渲染为真实的DOM
  也就是说这个函数是随着数据的更新变化而重新执行的。
componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。

unbind：只调用一次，指令与元素解绑时调用。

inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
  插入的时候调用一次


以上是directives 指令所接受的几个钩子函数，至于如何选择，那么根据你的需求。
如果是一次性的，直接使用inserted 或者是bind钩子，
官方提供了一个更为简单的写法：
Vue.directive('color-swatch', function (el, binding) {
  el.style.backgroundColor = binding.value
})
不需要写钩子函数，直接写操作的逻辑。
如上，构建了一个指令，名字叫做color-swatch.

而如果你希望你的指令能够根据数据的变化而重新执行的话，钩子函数就选择update。
效果如下：
<div id="hook-arguments-example" v-demo="message" >
  {{message}}
</div>

Vue.directive('demo', {
  bind: function (el, binding, vnode) {
    var s = JSON.stringify
    var text = el.innerHTML
    console.log('text',text)
    el.innerHTML = text.split('').reverse().join('')
  },
})
var vm = new Vue({
  el: '#hook-arguments-example',
  data: {
    message: 'hello!'
  }
})

如上边这个代码。那么我得到的结果是!olleh
但是，即使我使用vm.message="World"
那么结果为：不会发生任何变化.
但是如果改为
Vue.directive('demo', {
  update:function(el, binding, vnode){
    var s = JSON.stringify
    var text = binding.value
    console.log('text',text)
    el.innerHTML = text.split('').reverse().join('')
  }
})

那么每当所绑定的message发生变化的时候，指令就会触发。
但是，一个问题是，如果message已经被赋值了，且这个值没有发生变化，
就如上，vm实例中。message已经有值了，这个时候，那么我得到的结果是hello。
另外，如果message的值是异步获取的话，那么指令一般会在数据加载之前被挂载的，
所以也就不会有初始化的时候，指令没有执行的问题
但是，如果你开始修改message的值vm.message="world"
那么指令会触发，结果为dlow。
那么配合bind方法使用起来就更加舒爽。
Vue.directive('demo', {
  bind: function (el, binding, vnode) {
    var s = JSON.stringify
    var text = el.innerHTML
    console.log('text',text)
    el.innerHTML = text.split('').reverse().join('')
  },
  update:function(el, binding, vnode){
    var s = JSON.stringify
    var text = binding.value
    console.log('text',text)
    el.innerHTML = text.split('').reverse().join('')
  }
})

如上，bind解决了初始化绑定的时候，没有执行指令的问题，update解决了绑定的值变动的问题。
